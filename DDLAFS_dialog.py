# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DDLAFSDialog
                                 A QGIS plugin
 This plugin discovers saturation of faults in given area
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-04-18
        git sha              : $Format:%H$
        copyright            : (C) 2022 by example
        email                : example@example.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt.QtWidgets import QGraphicsLineItem, QGraphicsEllipseItem
from qgis.PyQt.QtWidgets import QGraphicsScene, QGraphicsView, QMessageBox

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import QVariant, pyqtSignal, QRectF
from PyQt5.QtGui import QMouseEvent, QColor, QPen, QBrush
from qgis.gui import QgsMapTool
from qgis.utils import iface
from qgis.core import QgsProject, QgsVectorLayer, QgsGeometry, QgsFeature, QgsPoint, QgsPointXY, \
QgsCircle, QgsField, QgsCoordinateReferenceSystem, QgsCoordinateTransform, \
QgsExpression, QgsExpressionContext, QgsExpressionContextUtils, QgsDistanceArea, QgsSymbol, QgsRendererRange, QgsGraduatedSymbolRenderer, edit
import processing
from math import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'DDLAFS_dialog_base.ui'))


class DDLAFSDialog(QtWidgets.QDialog, FORM_CLASS):

    basePointX = 0
    basePointY = 0
    mapTool = None

    def __init__(self, parent=None):
        """Constructor."""
        super(DDLAFSDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


        self.button_box.accepted.connect(self.toolAccept)
        self.button_box.rejected.connect(self.toolReject)
        self.mapTool = MapTool(iface.mapCanvas())
        self.mapTool.clicked.connect(self.setPoint)

        self.checkBox_rankFilter.stateChanged.connect(self.switchRankMode)
        self.checkBox_useMagnitude.stateChanged.connect(self.switchMagnitudeMode)
        self.pointsLayerComboBox.layerChanged.connect(self.mFieldComboBox.setLayer)
        self.faultsLayerComboBox.layerChanged.connect(self.mFieldComboBox_linesRank.setLayer)
        self.comboBox_pointInputMode.currentIndexChanged.connect(self.switchPointInputMode)
        self.checkBox_useMagnitude.stateChanged.connect(self.switchUseMagnitude)
        self.mFieldComboBox.setLayer(self.pointsLayerComboBox.currentLayer())
        self.mFieldComboBox_linesRank.setLayer(self.faultsLayerComboBox.currentLayer())
        self.spinBox_SegmentsCount.valueChanged.connect(self.changeSegmentCount)

        self.switchPointInputMode()
        self.switchRankMode()
        self.switchMagnitudeMode()
        self.changeSegmentCount()

    def changeSegmentCount(self):
        segmentCount = self.spinBox_SegmentsCount.value()

        scene = QGraphicsScene()

        sceneWidth = self.segmentsScene.width()

        pen = QPen()
        pen.setWidth(3)
        brush = QBrush()
        brush.setStyle(1)
        brush.setColor(QColor(255, 0, 0, 255))

        scene.addEllipse( QRectF(      100,   100    ,     sceneWidth*0.8,    sceneWidth*0.8) )
        scene.addEllipse( QRectF(      100+sceneWidth*0.2,   100+sceneWidth*0.2    ,     sceneWidth*0.4,    sceneWidth*0.4) )
        scene.addEllipse( QRectF(      100+sceneWidth*0.4,   100+sceneWidth*0.4    ,     1,    1), pen, brush )

        sceneCenter = 100+sceneWidth*0.4
        radius = sceneWidth*0.4
        for i in range(0, segmentCount+1):
            angle = radians(i * (180/segmentCount))
            scene.addLine( sceneCenter, sceneCenter,  sceneCenter-(sin(angle)*radius)  , sceneCenter-(cos(angle)*radius)  )
            scene.addLine( sceneCenter, sceneCenter,  sceneCenter+(sin(angle)*radius)  , sceneCenter+(cos(angle)*radius)  )

        self.segmentsScene.setScene(scene)

    def switchUseMagnitude(self):
        if self.checkBox_useMagnitude.isChecked():
            self.label_magField.setEnabled(True)
            self.mFieldComboBox.setEnabled(True)
        else:
            self.label_magField.setEnabled(False)
            self.mFieldComboBox.setEnabled(False)

    def switchPointInputMode(self):
        if self.comboBox_pointInputMode.currentIndex() == 0:
            self.label_points_coords.setVisible(False)
            self.lineEdit_Latitude.setVisible(False)
            self.lineEdit_Longitude.setVisible(False)
            self.label_Latitude.setVisible(False)
            self.label_Longitude.setVisible(False)
            self.spinBox_Magnitude.setVisible(False)
            self.label_Magnitude.setVisible(False)
            self.pointsLayerComboBox.setVisible(True)
            self.label_pointsLayer.setVisible(True)
            self.label_magField.setVisible(True)
            self.mFieldComboBox.setVisible(True)
        else:
            self.label_points_coords.setVisible(True)
            self.lineEdit_Latitude.setVisible(True)
            self.lineEdit_Longitude.setVisible(True)
            self.label_Latitude.setVisible(True)
            self.label_Longitude.setVisible(True)
            self.spinBox_Magnitude.setVisible(True)
            self.label_Magnitude.setVisible(True)
            self.pointsLayerComboBox.setVisible(False)
            self.label_pointsLayer.setVisible(False)
            self.label_magField.setVisible(False)
            self.mFieldComboBox.setVisible(False)

    def switchMagnitudeMode(self):
        checkBoxState = self.checkBox_useMagnitude.isChecked()
        self.label_Magnitude.setEnabled(checkBoxState)
        self.spinBox_Magnitude.setEnabled(checkBoxState)

    def switchRankMode(self):
        checkBoxState = self.checkBox_rankFilter.isChecked()
        self.checkBox_rankFilter_1.setEnabled(checkBoxState)
        self.checkBox_rankFilter_2.setEnabled(checkBoxState)
        self.checkBox_rankFilter_3.setEnabled(checkBoxState)
        self.label_linesRankField.setEnabled(checkBoxState)
        self.mFieldComboBox_linesRank.setEnabled(checkBoxState)

    def setPoint(self, point):
        self.basePointX = point.x()
        self.basePointY = point.y()
        self.lineEdit_Latitude.setText(str(self.basePointY))
        self.lineEdit_Longitude.setText(str(self.basePointX))

    def showEvent(self, e):
        iface.mapCanvas().setMapTool(self.mapTool)

    def toolAccept(self):

        useMagnitude = self.checkBox_useMagnitude.isChecked()
        rankFilter = self.checkBox_rankFilter.isChecked()
        outputMode = self.comboBox_Output.currentIndex() # 0 - csv (long), 1 - csv (short), 2 - shp (P max), 3 - shp (P >= mag), 4 - shp (Area)

        manualMode = None
        if self.comboBox_pointInputMode.currentIndex() == 0:
            manualMode = False
        else:
            manualMode = True

        if useMagnitude:
            #QMessageBox.warning(None, "WARNING", self.mFieldComboBox.currentField())
            if self.mFieldComboBox.currentField() == None:
                QMessageBox.warning(None, "WARNING", "No mag field were selected!")
                return 1

        if (self.comboBox_radiusUnits.currentIndex() == 0):
            radius = self.doubleSpinBox_Radius.value()
        else:
            radius = self.doubleSpinBox_Radius.value() * 1000

        root = QgsProject.instance().layerTreeRoot()

        if outputMode > 1:
            groupName = "FaultsData"
            groupNameAppendIterator = 1
            while (root.findGroup(groupName) != None):
                groupName = "FaultsData" + str(groupNameAppendIterator)
                groupNameAppendIterator += 1
            mainGroup = root.insertGroup(0, groupName)

        basePointLayer = None
        if self.comboBox_pointInputMode.currentIndex() == 0:
            basePointLayer = self.pointsLayerComboBox.currentLayer()
        else:
            basePointX = self.basePointX
            basePointY = self.basePointY

            basePointLayer = QgsVectorLayer("Point", "Base Point", "memory")

            basePoint = QgsPointXY(basePointX, basePointY)
            basePointGeometry = QgsGeometry.fromPointXY(basePoint)
            f = QgsFeature()
            f.setGeometry(basePointGeometry)
            basePointLayer.dataProvider().addFeatures([f])
            basePointLayer.updateExtents()
            if outputMode > 1:
                QgsProject.instance().addMapLayer(basePointLayer, False)
                mainGroup.addLayer(basePointLayer)
            del f

        mainSegmentCount = int(self.spinBox_SegmentsCount.value())
        segmentCount = mainSegmentCount * 2

        if outputMode == 0:
            with open(self.mQgsFileWidget_filePath.filePath(), 'w') as file:
                file.write('Lat, Long, R, Mag, ∑L')
                for i in range(1, mainSegmentCount+1):
                    file.write(f', ψ{i}')
                for i in range(1, mainSegmentCount+1):
                    file.write(f', P{i}')
                file.write('\n')
        if outputMode == 1:
            with open(self.mQgsFileWidget_filePath.filePath(), 'w') as file:
                file.write('Lat, Long')
                for i in range(1, mainSegmentCount+1):
                    file.write(f', ψ{i}')
                file.write('\n')
            file.close()

        faultsLayer = self.faultsLayerComboBox.currentLayer()

        if basePointLayer.crs().authid() != "EPSG:4326":
            reprojected = processing.run('native:reprojectlayer', {
                'INPUT': basePointLayer,
                'TARGET_CRS': 'EPSG:4326',
                'OUTPUT': 'memory:'
            })['OUTPUT']
            basePointLayer = reprojected
        if faultsLayer.crs().authid() != "EPSG:4326":
            reprojected = processing.run('native:reprojectlayer', {
                'INPUT': faultsLayer,
                'TARGET_CRS': 'EPSG:4326',
                'OUTPUT': 'memory:'
            })['OUTPUT']
            faultsLayer = reprojected

        groupNameAppendIterator = 1
        for basePoint in basePointLayer.getFeatures():
            if useMagnitude:

                if manualMode:
                    M = self.spinBox_Magnitude.value()
                else:
                    M = basePoint.attributes()[basePointLayer.fields().indexFromName(self.mFieldComboBox.currentField())]

                if (M >= 7.2):
                    R = (10**(-2.29 + 0.57 * M)/2)*1000
                else:
                    R = 30000
            else:
                if manualMode:
                    R = self.doubleSpinBox_Radius.value()
                else:
                    R = basePoint.attributes()[basePointLayer.fields().indexFromName('R')]

            if outputMode > 1:
                groupName = "Point" + str(groupNameAppendIterator)
                group = mainGroup.insertGroup(0, groupName)
                groupNameAppendIterator += 1

            basePointX = basePoint.geometry().asPoint().x()
            basePointY = basePoint.geometry().asPoint().y()

            points = []
            for i in range(0, 360):
                azimuth = 360-(i)
                pointCoordinates = self.vincenty_direct(basePointY, basePointX, R, azimuth)
                points.append(QgsPointXY(pointCoordinates[1], pointCoordinates[0]))

            segmentLayer = QgsVectorLayer("Polygon", "Area", "memory")
            segmentLayer.setOpacity(0.15)

            if outputMode > 1:
                QgsProject.instance().addMapLayer(segmentLayer, False)
                group.addLayer(segmentLayer)
            segmentLayerDP = segmentLayer.dataProvider()
            segmentLayerDP.addAttributes([QgsField("segment_id", QVariant.Int)])
            segmentLayer.updateFields()
            fpoly = QgsFeature()
            fpoly.setGeometry(QgsGeometry.fromPolygonXY([points]))

            segmentLayerDP.addFeatures([fpoly])
            segmentLayer.updateExtents()

            if outputMode == 4:
                continue

            clipResult = processing.run("native:clip", {
                    'INPUT': faultsLayer,
                    'OVERLAY': segmentLayer,
                    'OUTPUT': 'memory:'
            })['OUTPUT']

            if rankFilter:
                R1 = self.checkBox_rankFilter_1.isChecked()
                R2 = self.checkBox_rankFilter_2.isChecked()
                R3 = self.checkBox_rankFilter_3.isChecked()

                with edit(clipResult):
                    for f in clipResult.getFeatures():
                        rankValue = f.attributes()[clipResult.fields().indexFromName(self.mFieldComboBox_linesRank.currentField())]
                        rank = 0
                        if rankValue in (1, '1', 'I'):
                            rank = 1
                        elif rankValue in (2, '2', 'II'):
                            rank = 2
                        elif rankValue in (3, '3', 'III'):
                            rank = 3
                        if (rank == 1 and not R1) or (rank == 2 and not R2) or (rank == 3 and not R3) or (rank == 0):
                            clipResult.deleteFeature(f.id())

            explodedLines = processing.run("native:explodelines", {
                    'INPUT': clipResult,
                    'OUTPUT': 'memory:'
            })['OUTPUT']

            azimuthStep = 360/segmentCount
            lengths = 0 # сумма длин всех линеаментов
            segmentLengths = [0] * int(segmentCount/2)
            d = QgsDistanceArea()
            d.setEllipsoid('WGS84')
            for f in explodedLines.getFeatures():
                geom = f.geometry().asPolyline()
                start_point = QgsPoint(geom[0])
                end_point = QgsPoint(geom[1])
                azimuth = start_point.azimuth(end_point)
                azimuth = azimuth % 180
                segment = int(azimuth // azimuthStep)
                segmentLengths[segment] += (d.convertAreaMeasurement(d.measureLength(f.geometry()), 1)) *1000 *1000

                l = (d.convertAreaMeasurement(d.measureLength(f.geometry()), 1))
                lengths += l

            lengths = lengths * 1000 * 1000

            psi = [0]*int(mainSegmentCount)
            for i in range(0, mainSegmentCount):
                psi[i] = ( (i+1) * (180/mainSegmentCount) - (azimuthStep/2) )

            P = [0]*int(mainSegmentCount)
            if lengths == 0:
                for i in range(mainSegmentCount):
                    P[i] = nan
            else:
                for i in range(mainSegmentCount):
                    P[i] = round( (segmentLengths[i] / lengths * 100), 1)

            # .csv table
            if outputMode == 0:
                with open(self.mQgsFileWidget_filePath.filePath(), 'a') as file:
                    file.write(f'{basePointX}')
                    file.write(f', {basePointY}')
                    file.write(f', {R}')
                    file.write(f', {M}')
                    file.write(f', {lengths}')
                    for i in range(1, mainSegmentCount+1):
                        file.write(f', {psi[i-1]}')
                    for i in range(1, mainSegmentCount+1):
                        file.write(f', {P[i-1]}')
                    file.write('\n')
                file.close()
            elif outputMode == 1:
                # short output

                with open(self.mQgsFileWidget_filePath.filePath(), 'a') as file:
                    file.write(f'{basePointX}')
                    file.write(f', {basePointY}')
                    for i in range(1, mainSegmentCount+1):
                        file.write(f', {psi[i-1]}')
                    file.write('\n')
                file.close()

            # .shp-file
            else:

                azimuthLinesLayer = QgsVectorLayer("LineString", "AzimuthLines", "memory")
                azimuthLinesLayer.dataProvider().addAttributes([QgsField("id", QVariant.Int), QgsField("psi", QVariant.Double), QgsField("P", QVariant.Double)])
                azimuthLinesLayer.updateFields()

                rangeList = []
                blueSymbol = QgsSymbol.defaultSymbol(1)
                blueSymbol.setWidth(1.00)
                blueSymbol.setColor(QColor("#7777ff"))

                greenSymbol = QgsSymbol.defaultSymbol(1)
                greenSymbol.setWidth(1.00)
                greenSymbol.setColor(QColor("#56e38f"))

                yellowSymbol = QgsSymbol.defaultSymbol(1)
                yellowSymbol.setWidth(1.00)
                yellowSymbol.setColor(QColor("#fae823"))

                redSymbol = QgsSymbol.defaultSymbol(1)
                redSymbol.setWidth(1.00)
                redSymbol.setColor(QColor("#d93114"))

                rangeList.append(QgsRendererRange(0, 50, blueSymbol, '<50%'))
                rangeList.append(QgsRendererRange(50, 75, greenSymbol, '50-75%'))
                rangeList.append(QgsRendererRange(75, 95, yellowSymbol, '75-95%'))
                rangeList.append(QgsRendererRange(95, 100, redSymbol, '>95%'))

                renderer = QgsGraduatedSymbolRenderer('P', rangeList)

                azimuthLinesLayer.setRenderer(renderer)

                QgsProject.instance().addMapLayer(azimuthLinesLayer, False)
                group.addLayer(azimuthLinesLayer)

                # Pmax
                if outputMode == 2:
                    maxPId = -1
                    for i in range (0, mainSegmentCount):
                        if (P[i] != nan):
                            maxPId = i
                            break
                    for i in range(0, mainSegmentCount):
                        if P[i] == nan:
                            continue
                        if (P[i] > P[maxPId]):
                            maxPId = i
                    if maxPId != -1:
                        azimuth = psi[maxPId]
                        linePoints = self.vincenty_direct(basePointY, basePointX, R, azimuth)
                        line1 = QgsGeometry.fromPolylineXY([basePoint.geometry().asPoint(), QgsPointXY(linePoints[1], linePoints[0])])
                        azimuth = azimuth + 180
                        linePoints = self.vincenty_direct(basePointY, basePointX, R, azimuth)
                        line2 = QgsGeometry.fromPolylineXY([basePoint.geometry().asPoint(), QgsPointXY(linePoints[1], linePoints[0])])
                        f = QgsFeature()
                        f.setGeometry(line1.combine(line2))
                        f.setFields(azimuthLinesLayer.fields())
                        f['id'] = maxPId+1
                        f['psi'] = psi[maxPId]
                        f['P'] = P[maxPId]
                        azimuthLinesLayer.dataProvider().addFeatures([f])
                        azimuthLinesLayer.updateExtents()

                # P >= mag
                if outputMode == 3:
                    for i in range(0, mainSegmentCount):
                        if P[i] == 0 or P[i] == nan:
                            continue
                        linePoints = []
                        azimuth = psi[i]
                        linePoints.append( self.vincenty_direct(basePointY, basePointX, R, azimuth) )
                        line1 = QgsGeometry.fromPolylineXY([basePoint.geometry().asPoint(), QgsPointXY(linePoints[0][1], linePoints[0][0])])
                        azimuth = azimuth + 180
                        linePoints.append( (self.vincenty_direct(basePointY, basePointX, R, azimuth)) )
                        line2 = QgsGeometry.fromPolylineXY([basePoint.geometry().asPoint(), QgsPointXY(linePoints[1][1], linePoints[1][0])])
                        f = QgsFeature()
                        f.setGeometry(line1.combine(line2))
                        f.setFields(azimuthLinesLayer.fields())
                        f['id'] = i+1
                        f['psi'] = psi[i]
                        f['P'] = P[i]
                        azimuthLinesLayer.dataProvider().addFeatures([f])
                    azimuthLinesLayer.updateExtents()

    def toolReject(self):
        iface.mapCanvas().unsetMapTool(self.mapTool)
        self.reject()

    def vincenty_direct(self, φ1, L1, s, α1):
        f = 1/298.257223563 # flattening of the ellipsoid
        a = 6378137.0 # semi-major axis length
        b = 6356752.314245 # semi-minor axis length

        piD4 = atan( 1.0 )
        two_pi = piD4 * 8.0
        φ1 = φ1 * piD4 / 45.0
        L1 = L1 * piD4 / 45.0
        α1 = α1 * piD4 / 45.0
        if ( α1 < 0.0 ) :
            α1 = α1 + two_pi
            if ( α1 > two_pi ) :
                α1 = α1 - two_pi

        sinα1 = sin(α1)
        cosα1 = cos(α1)

        U1 = atan( (1-f) * tan(φ1) ) #
        σ1 = atan2( tan(U1), cos(α1) ) #

        sinα = cos(U1)*sin(α1) #
        cosSqrα = 1 - sinα*sinα
        uSqr = cosSqrα * ((a*a - b*b) / (b*b)) #
        A = 1 + ( uSqr / 16384 ) * (4096 + uSqr * (-768 + uSqr * (320 - 175 * uSqr ) ) ) #
        B = (uSqr / 1024) * (256 + uSqr * (-128 + uSqr * (74 - 47 * uSqr) ) ) #

        σ = s / (b * A) #

        σ_last = σ * 2

        while (abs(σ_last - σ) > 1.0e-9):
            x2σm = 2 * σ1 + σ #
            delta = B * sin(σ) * ( # purple
            cos(x2σm) + (B/4) * ( # blue
            cos(σ) * (-1 + 2 * cos(x2σm) * cos(x2σm) ) - (B/6) * cos(x2σm) * (-3 +4 * sin(σ)*sin(σ) ) * (-3 +4 * cos(x2σm)*cos(x2σm) ) ) ) # grey
            σ_last = σ
            σ = s / (b * A) + delta

        x = sin(U1)*sin(σ) - cos(U1)*cos(σ)*cos(σ1)
        φ2 = atan2(sin(U1) * cos(σ) + cos(U1)*sin(σ)*cos(α1), (1-f) * sqrt(sinα*sinα + x*x) )
        φ2 = atan2 ( (sin(U1) * cos(σ) + cos(U1) * sin(σ) * cos(α1) ), ((1-f) * sqrt( pow(sinα, 2) +  pow(sin(U1) * sin(σ) - cos(U1) * cos(σ) * cos(α1), 2))))
        λ = atan2(sin(σ) * sin(α1), cos(U1) * cos(σ) - sin(U1) * sin(σ)*cos(α1))
        C = f/16 * cosSqrα * (4 + f*(4 - 3*cosSqrα ) )
        L = λ - (1 - C)*f*sinα * (σ + C*sin(σ) * (cos(x2σm) + C*cos(σ)*(-1 +2*cos(x2σm)*cos(x2σm) )) )
        L2 = L1 + L
        α2 = atan2(sinα, -x)
        α2 = atan2 ( sinα, (-sin(U1) * sin(σ) + cos(U1) * cos(σ) * cos(α1)))
        α2 = α2 + two_pi / 2.0

        α2 = α2 * 45.0 / piD4
        L2 = L2 * 45.0 / piD4
        φ2 = φ2 * 45.0 / piD4

        return(φ2, L2, α2)

class MapTool(QgsMapTool):

    clicked = pyqtSignal('QgsPointXY')

    def __init__(self, canvas):
        super().__init__(canvas)

    def canvasPressEvent(self, e):
        super().canvasPressEvent(e)

        sourceCRS = QgsProject.instance().crs()
        destinationCRS = QgsCoordinateReferenceSystem(4326)
        transform = QgsCoordinateTransform()
        transform.setSourceCrs(sourceCRS)
        transform.setDestinationCrs(destinationCRS)
        mapPoint = e.mapPoint()
        mapPoint = transform.transform(mapPoint)
        print(mapPoint.x())
        print(mapPoint.y())
        self.clicked.emit(mapPoint)
